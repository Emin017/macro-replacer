import json
import subprocess
import os
import argparse

# Defaults
# Defaults
VERILOG_FILE = "ysyxSoCFull.v"
AST_FILE = "ysyxSoCFull.ast.json"
TARGET_MODULE = "ram_2x3"
MACRO_NAME = "xxxxxxxxxxxxxxxxx"
MACRO_DEF_FILE = "pdk_macro.v"
MACRO_AST_FILE = "macro.ast.json"

def run_slang(verilog_file, ast_file):
    print(f"正在用 slang 生成 AST: {ast_file} (源文件: {verilog_file})")
    try:
        # Use slang to emit JSON AST to the given file
        subprocess.run(["slang", verilog_file, "--ignore-unknown-modules", "--ast-json", ast_file], check=True)
    except subprocess.CalledProcessError as e:
        print(f"slang 调用失败: {e}")
        raise

def find_module(ast, name):
    if isinstance(ast, dict):
        if ast.get("kind") == "ModuleDeclaration" and ast.get("name") == name:
            return ast
        for v in ast.values():
            result = find_module(v, name)
            if result:
                return result
    elif isinstance(ast, list):
        for item in ast:
            result = find_module(item, name)
            if result:
                return result
    return None

def jq_extract_module(ast_file, name):
    """Use jq to extract the module node and its ports from ast_file.
    Returns a dict with structure {"ports": [...]} or None if not found.
    
    The jq filter searches for Instances (generated by slang for top-level modules or instances).
    """
    # Search for instances where body.name matches the module name
    jq_filter = f'.. | objects | select(.kind == "Instance") | select(.body | objects) | select(.body.name == "{name}") | .body.members[] | objects | select(.kind == "Port") | {{name, type, direction}}'
    try:
        proc = subprocess.run(["jq", "-c", jq_filter, ast_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    except FileNotFoundError:
        print("jq 未安装或不可用，无法使用 jq 作为回退方法")
        return None
    
    if proc.stderr and "error" in proc.stderr.lower():
        print(f"[DEBUG] jq stderr: {proc.stderr[:200]}")
    
    out = proc.stdout.strip()
    if not out:
        print(f"[DEBUG] jq 返回空输出，尝试的模块名: {name}")
        return None

    ports = []
    for line in out.splitlines():
        line = line.strip()
        if not line: continue
        try:
            ports.append(json.loads(line))
        except json.JSONDecodeError:
            pass
    
    print(f"[DEBUG] jq 查询成功，提取到 {len(ports)} 个端口")
    return {"ports": ports} if ports else None

def jq_extract_macro_ports(ast_file, macro_name):
    """Extract ports for the macro definition from its AST."""
    # Similar filter but adjusted if structure differs; usually slang structure is consistent
    # For standalone file, macro is likely top level, appearing under design.members as Instance
    jq_filter = f'.design.members[] | select(.name == "{macro_name}") | .body.members[] | select(.kind == "Port") | {{name, type, direction}}'
    
    try:
        proc = subprocess.run(["jq", "-c", jq_filter, ast_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    except FileNotFoundError:
        return None
        
    out = proc.stdout.strip()
    if not out:
        # Fallback query if top level structure is slightly different (e.g. not under nested design)
        # return jq_extract_module(ast_file, macro_name)
        return None

    ports = []
    for line in out.splitlines():
        try:
            ports.append(json.loads(line))
        except:
            pass
    return ports

def gen_verilog(module, target_module_name, macro_name, macro_ports=None):
    """Generate a wrapper module named `target_module_name` which instantiates `macro_name`.
    `module` is the AST node describing the original module (the wrapper).
    `macro_ports` is the list of ports for the inner macro.
    """
    ports = module.get("ports", [])
    port_lines = []
    
    # Analyze Outer Ports for Heuristics
    outer_inputs = []
    outer_outputs = []
    for p in ports:
        d = p.get("direction", "").lower()
        n = p.get("name", "")
        if "in" in d: outer_inputs.append(n)
        if "out" in d: outer_outputs.append(n)

    # 1. Define Outer Module Ports
    for port in ports:
        direction = port.get("direction", "input")
        width = port.get("type", "")
        name = port.get("name", "")
        dir_map = {"in": "input", "out": "output"}
        direction = dir_map.get(direction.lower(), direction)
        
        if width and width != "logic":
            decl = f"{direction} {width} {name}"
        else:
            decl = f"{direction} {name}"
        port_lines.append(decl)

    # 2. Define Instance Connections with Heuristics
    connect_lines = []
    if macro_ports:
        for mp in macro_ports:
            m_name = mp.get("name")
            m_dir = mp.get("direction", "").lower()
            m_type = mp.get("type", "logic")
            
            # Simple Heuristic Matching
            candidate = ""
            if "out" in m_dir:
                # If only one outer output, match it
                if len(outer_outputs) == 1:
                    candidate = outer_outputs[0]
            elif "in" in m_dir:
                # Try name matching
                # Check for "clk"
                if "clk" in m_name.lower():
                    # Find outer clk
                    clks = [x for x in outer_inputs if "clk" in x.lower()]
                    if clks: candidate = clks[0] # Pick first found
                elif "wen" in m_name.lower():
                    # Write Enable
                    wens = [x for x in outer_inputs if "wen" in x.lower() or "en" in x.lower()]
                    if wens: candidate = wens[0]
                elif "addr" in m_name.lower() or m_name == "A":
                    # Address
                    addrs = [x for x in outer_inputs if "addr" in x.lower()]
                    if addrs: candidate = addrs[0]
                elif "data" in m_name.lower() or m_name == "D":
                    # Data In
                    datas = [x for x in outer_inputs if "data" in x.lower()]
                    if datas: candidate = datas[0]

            connect_lines.append(f".{m_name}({candidate}), // {m_dir.capitalize()} {m_type}")
    else:
        # Fallback if no macro ports found
        pass

    verilog = f"module {target_module_name}(\n    " + ",\n    ".join(port_lines) + "\n);\n\n"
    verilog += f"    {macro_name} u_mem (\n        " + ",\n        ".join(connect_lines) + "\n    );\n\n"
    verilog += "endmodule\n"
    return verilog

def main():
    parser = argparse.ArgumentParser(description="Extract module ports from AST and generate wrapper.")
    parser.add_argument("--verilog", default=VERILOG_FILE)
    parser.add_argument("--ast", default=AST_FILE)
    parser.add_argument("--module", default=TARGET_MODULE)
    parser.add_argument("--macro", default=MACRO_NAME)
    parser.add_argument("--macro-def", default=MACRO_DEF_FILE, help="Macro definition Verilog file")
    parser.add_argument("--out", default=None)
    parser.add_argument("--force", action="store_true")

    args = parser.parse_args()
    
    verilog_file = args.verilog
    ast_file = args.ast
    target = args.module
    macro = args.macro
    macro_def = args.macro_def
    out_file = args.out or f"new_{target}.v"
    
    # 1. Generate/Parse Target Module AST
    if args.force or not os.path.exists(ast_file):
        run_slang(verilog_file, ast_file)

    print(f"使用 jq 从 {ast_file} 中查找模块 {target}...")
    module_info = jq_extract_module(ast_file, target)
    if not module_info:
        print(f"Module {target} not found in {ast_file}!")
        return

    # 2. Parse Macro AST
    macro_ports = []
    if macro_def and os.path.exists(macro_def):
        macro_ast_file = "macro.ast.json"
        # Always run slang on macro def to be safe/fresh, it's fast
        run_slang(macro_def, macro_ast_file)
        
        print(f"提取宏模块 {macro} 的端口...")
        macro_ports = jq_extract_macro_ports(macro_ast_file, macro)
        if not macro_ports:
            print(f"[WARN] 无法从 {macro_def} 提取到宏 {macro} 的端口")
    
    # 3. Generate Wrapper
    verilog = gen_verilog(module_info, target, macro, macro_ports)
    with open(out_file, "w") as f:
        f.write(verilog)
    print(f"新模块已生成：{out_file}")

    print("\n[端口信息摘要]")
    print(f"Target Module ({target}) Ports:")
    for p in module_info.get("ports", []):
         print(f"  - {p.get('name'):<15} {p.get('direction'):<10} {p.get('type')}")
    
    if macro_ports:
        print(f"\nMacro Module ({macro}) Ports:")
        for p in macro_ports:
             print(f"  - {p.get('name'):<15} {p.get('direction'):<10} {p.get('type')}")

if __name__ == "__main__":
    main()